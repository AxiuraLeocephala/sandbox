# Розыскивается Карта живой или мертвой. В криминальных кругах известна 
# как ассоциативный массив или словарь. Награда: почет и уважение

import logging 

UNICODE = "utf8"

dict_demo: dict = {
    "ключ_0": "значение_0",
    "ключ_1": "значение_1",
    "ключ_2": "значение_2",
    "ключ_3": "значение_3",
    "ключ_4": "значение_4",
    bytes("0101", UNICODE): "значение_5",
    0: "значение_6",
    (0, 1, 2, 3): "значение_7",
    frozenset([0, 1, 2, 3]): "значние_8"
}

# Возвращает объект, похожий на множество, который содержит ключи словаря
keys_dict_demo = dict_demo.keys()

# Возвращает объект, похожий на множество, который содержит значения словаря
values_dict_demo = dict_demo.values()

# Возвращает объект, похожий на множество, который содержит кортежи. 
# Каждый кортеж содержит ключ и значение
couples_dict_demo = dict_demo.items()

# Возвращает новый словарь, ключи которого - элементы итерируемого объекта,
# а значения - указанное дефолтное значение либо None
new_dict = dict.fromkeys([1, 2, 3, 4], "значение_")
i = 0
for k in new_dict.keys():
    new_dict[k] = new_dict[k] + str(i)
    i += 1

# Возвращет значение по ключу. Если ключа нет в словаре - возвращает None
# либо указанное дефолтное значение  
v_1 = new_dict.get(1)
v_2 = new_dict.get(5, "такого ключа нет")

# Извлекает пару по ключу, возвращает только значение. Если нет ключа в 
# словаре - возвращает указанное дефолтное значение или поднимает 
# KeyError, если не указано дефолтное значение
v_1 = new_dict.pop(1)
try:
    v_2 = new_dict.pop(0, None)
    v_3 = new_dict.pop(0)
except KeyError as error:
    logging.warning("такого ключа нет")

print(v_1, v_2, new_dict)
