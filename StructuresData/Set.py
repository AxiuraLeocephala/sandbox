set_1: set = {1, 2, 3, 4}
set_2: set = {1, 2, 5, 6}
set_3: set = {1, 2, 5, 7}
set_4: set = set("collection")
set_5: set = {1, 2, 3, 4, 5, 6, 7}

# Возвращает новое множество, содержащее элементы целевого множества, 
# которых нет в других множествах (логическое НЕ)
difference_set_1 = set_1.difference(set_2, set_3)

# Работает аналогично методу difference, но изменяет целевой массив
set_1.difference_update(set_2)

# Возвращет новое множество, содержащее элементы, которые есть во всех
# множествах (логическое И)
intersection_set_1 = set_2.intersection(set_3)

# Работает аналогично методу intersepter, но изменяет целевой массив
set_2.intersection_update(set_3)

# Возвращает True, если множества не имеют пересечения
answer_is_dis_joint = set_1.isdisjoint(set_4)

# Возвращает True, если целевое множество является подмножеством другого
# множества
answer_is_sub_set = set_1.issubset(set_5)

# Возвращает True, если целевое множество является супермножеством 
# другого множества 
answer_is_super_ser = set_5.issuperset(set_1)

# Возвращает новое множество, содержащее элементы, которые есть ровно 
# в одном из множеств
symmetric_difference = set_2.symmetric_difference(set_1)

# Работает аналогично методу symmetric_difference, но изменяет
# целевое множество
set_2.symmetric_difference_update(set_1)

# Возвращает новое множество, содержащее уникальные элементы множеств 
# (можео передать любой итерируемый объект)
# !!! При объединении множества и словаря новое множество будет
# сожержать ключи словаря 
set_6 = set_1.union(set_2, 
                                  {1, 2, 3}, 
                                  [5, 6], 
                                  (7, 8), 
                                  "collection", 
                                  {"0": 9, "1": 10})

# Работыет аналогично методу remove, но не поднимает исключение, 
# если элемета нет в множестве
set_1.discard(3)
set_1.discard(0)

# Работыет аналогично методу union, но изменяет целевое множество
set_1.update(set_2)

print(set_6)


# То же самое, что и обычное множество, но не имеет методов для изменения
# множества (иммутабельный) 
frozen_set_1: frozenset = frozenset([1, 2, 3, 4, 5])

print(frozen_set_1, type(frozen_set_1))